对于普通的嵌套子查询来说，先执行子查询，然后将执行结果返回给外部查询

对于相关子查询来说，因为子查询中涉及了外部查询的列，所以通常是先执行 
外部查询，把外部查询的列传给子查询，子查询执行结束后，返回给外部查询 
大致就是这个过程。 

另外，最清晰的方法就是查看执行计划，因为有可能涉及优化器的优化


 select p.* ,（select count(ID) FROM CLERK_EXAM_QUESTION  where EXAM_PAPER_ID=p.ID) as examcount   from CLERK_EXAM_PAPER  p ;




select * from     customer_drug_order   o where ( (exist   select * from  drug_store 
where id=o.drug_store_id and   drug_store_hq_id ='85a6bb3194fe4c14b3015ce958746edd'))


85a6bb3194fe4c14b3015ce958746edd




SELECT
	* 
FROM
	customer_drug_order  o 
WHERE
	(	exist (SELECT * FROM drug_store WHERE id = o.drug_store_id AND drug_store_hq_id = '85a6bb3194fe4c14b3015ce958746edd'   ) )



select * from T1 where exists(select 1 from T2 where T1.a=T2.a) ;

    T1数据量小而T2数据量非常大时，T1<<T2 时，1) 的查询效率高。

 select * from T1 where T1.a in (select T2.a from T2) ;
 
 
 
 
 
 
 
 select rownum  rn, * from  (SELECT     *
           
            FROM QUESTION_CATEGORY c
             ) a
 missing expression   ->   select  a.*,rownum  rn from  (SELECT     *
           
            FROM QUESTION_CATEGORY c
             ) a

 
 
 break 跳出  flag 标记全累加状态
 
 select * from COURSE c left join USER_COURSE u on 
c.id = u.course_id and u.USER_ID='363efe09fac34ee59ce31cfe54270245' and u.year< '2019'   and  c.IS_ACTIVE=1
where u.id is null
 
 
 
 
select ID,USER_ID,COURSE_ID,COURSE_NAME,YEAR,STATUS,ADD_TIME,COURSE_POINT,COURSE_PIC_URL from  (select *  from (SELECT  coursetmp.*,t.course_id as course_id_right,t.LAST_WATCH_TIME
as LAST_WATCH_TIME  FROM(SELECT u.ID, u.USER_ID, u.COURSE_ID as COURSE_ID, u.COURSE_NAME, u.YEAR, u.STATUS,u.ADD_TIME,c.COURSE_POINT,c.COURSE_PIC_URL
from USER_COURSE u left join COURSE c on u.COURSE_ID=c.ID   where u.user_id='363efe09fac34ee59ce31cfe54270245' AND  YEAR=2019)coursetmp   left  join  (select * from   (select v.course_id,
max(l.LAST_WATCH_TIME) AS LAST_WATCH_TIME from video v inner join USER_VIDEO_LOG l  on v.id=l.VIDEO_ID   group by  v.course_id) ) t  on t.COURSE_ID=coursetmp.COURSE_ID  ) alltmp order by
case when alltmp.LAST_WATCH_TIME  is null then 0 else 1  end   desc, alltmp.LAST_WATCH_TIME desc,alltmp.ADD_TIME desc) where ROWNUM<=3

 
