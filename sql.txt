对于普通的嵌套子查询来说，先执行子查询，然后将执行结果返回给外部查询

对于相关子查询来说，因为子查询中涉及了外部查询的列，所以通常是先执行 
外部查询，把外部查询的列传给子查询，子查询执行结束后，返回给外部查询 
大致就是这个过程。 

另外，最清晰的方法就是查看执行计划，因为有可能涉及优化器的优化



@Select({
			"SELECT  user_info_tmp.*,r.REWARD_MONEY,r.USER_COURSE_ID from (select ID,USER_ID,COURSE_ID,COURSE_NAME,YEAR,STATUS,ADD_TIME,COURSE_POINT,COURSE_PIC_URL,COURSE_CONTENT from  (select *  from (SELECT  coursetmp.*,t.course_id as course_id_right,t.LAST_WATCH_TIME " ,
					"as LAST_WATCH_TIME  FROM(SELECT u.ID, u.USER_ID, u.COURSE_ID as COURSE_ID, u.COURSE_NAME, u.YEAR, u.STATUS,u.ADD_TIME,c.COURSE_POINT,c.COURSE_PIC_URL,c.COURSE_CONTENT " ,
					"from USER_COURSE u left join COURSE c on u.COURSE_ID=c.ID   where u.user_id=#{userId} AND  YEAR=#{time} AND (u.STATUS='1'OR u.STATUS='2' OR u.STATUS='4')) coursetmp   left  join  (select * from   (select v.course_id, " ,
					"max(l.LAST_WATCH_TIME) AS LAST_WATCH_TIME from video v inner join USER_VIDEO_LOG l  on v.id=l.VIDEO_ID   group by  v.course_id) ) t  on t.COURSE_ID=coursetmp.COURSE_ID  ) alltmp order by " ,
					"case when alltmp.LAST_WATCH_TIME  is null then 0 else 1  end   desc, alltmp.LAST_WATCH_TIME desc,alltmp.ADD_TIME desc)   UNION  ALL  SELECT * FROM ( SELECT u.ID,USER_ID,u.COURSE_ID,u.COURSE_NAME,u.YEAR,u.STATUS,u.ADD_TIME,c.COURSE_POINT,c.COURSE_PIC_URL,c.COURSE_CONTENT ",
			"from USER_COURSE u left join  COURSE c on u.COURSE_ID=c.ID WHERE u.USER_ID=#{userId}   AND u.STATUS='3'  AND  u.YEAR=#{time} ORDER BY u.ADD_TIME DESC)) user_info_tmp    left join USER_COURSE_REWARD  r on   user_info_tmp.COURSE_ID=r.USER_COURSE_ID ORDER BY CASE WHEN user_info_tmp.STATUS=3 THEN 0 ELSE 1  END DESC,user_info_tmp.ADD_TIME DESC"
	})




 select p.* ,（select count(ID) FROM CLERK_EXAM_QUESTION  where EXAM_PAPER_ID=p.ID) as examcount   from CLERK_EXAM_PAPER  p ;




select * from     customer_drug_order   o where ( (exist   select * from  drug_store 
where id=o.drug_store_id and   drug_store_hq_id ='85a6bb3194fe4c14b3015ce958746edd'))


85a6bb3194fe4c14b3015ce958746edd




SELECT
	* 
FROM
	customer_drug_order  o 
WHERE
	(	exist (SELECT * FROM drug_store WHERE id = o.drug_store_id AND drug_store_hq_id = '85a6bb3194fe4c14b3015ce958746edd'   ) )



select * from T1 where exists(select 1 from T2 where T1.a=T2.a) ;

    T1数据量小而T2数据量非常大时，T1<<T2 时，1) 的查询效率高。

 select * from T1 where T1.a in (select T2.a from T2) ;
 
 
 
 
 
 
 
 select rownum  rn, * from  (SELECT     *
           
            FROM QUESTION_CATEGORY c
             ) a
 missing expression   ->   select  a.*,rownum  rn from  (SELECT     *
           
            FROM QUESTION_CATEGORY c
             ) a

 
 
 break 跳出  flag 标记全累加状态
 
 select * from COURSE c left join USER_COURSE u on 
c.id = u.course_id and u.USER_ID='363efe09fac34ee59ce31cfe54270245' and u.year< '2019'   and  c.IS_ACTIVE=1
where u.id is null
 
 select   MAX(DISCOUNT_AMOUNT) AS DISCOUNT_AMOUNT   from DRUG_STORE_SALES_RULE_DETAIL d  where d.RULE_ID IN(SELECT r.ID FROM DRUG_STORE_SALES_RULE r
            where r.DRUG_STORE_ID=#{drugStoreId} AND r.IS_ACTIVE='1' AND SYSDATE >= r.BEGIN_DATE AND SYSDATE <r.END_DATE)
            AND #{totalprice}>=TOTAL_AMOUNT AND IS_ACTIVE='1'
 
 
select ID,USER_ID,COURSE_ID,COURSE_NAME,YEAR,STATUS,ADD_TIME,COURSE_POINT,COURSE_PIC_URL from  (select *  from (SELECT  coursetmp.*,t.course_id as course_id_right,t.LAST_WATCH_TIME
as LAST_WATCH_TIME  FROM(SELECT u.ID, u.USER_ID, u.COURSE_ID as COURSE_ID, u.COURSE_NAME, u.YEAR, u.STATUS,u.ADD_TIME,c.COURSE_POINT,c.COURSE_PIC_URL
from USER_COURSE u left join COURSE c on u.COURSE_ID=c.ID   where u.user_id='363efe09fac34ee59ce31cfe54270245' AND  YEAR=2019)coursetmp   left  join  (select * from   (select v.course_id,
max(l.LAST_WATCH_TIME) AS LAST_WATCH_TIME from video v inner join USER_VIDEO_LOG l  on v.id=l.VIDEO_ID   group by  v.course_id) ) t  on t.COURSE_ID=coursetmp.COURSE_ID  ) alltmp order by
case when alltmp.LAST_WATCH_TIME  is null then 0 else 1  end   desc, alltmp.LAST_WATCH_TIME desc,alltmp.ADD_TIME desc) where ROWNUM<=3

 
 
 select  count(DECODE(IS_ACTIVE, 1,9))  as   isyes,count(DECODE(IS_ACTIVE, 2,68)) as   isnotyes from    course;
